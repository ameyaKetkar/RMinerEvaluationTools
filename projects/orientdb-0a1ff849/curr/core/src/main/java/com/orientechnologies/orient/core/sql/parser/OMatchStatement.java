/* Generated By:JJTree: Do not edit this line. OMatchStatement.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=true,NODE_PREFIX=O,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.orientechnologies.orient.core.sql.parser;

import com.orientechnologies.common.listener.OProgressListener;
import com.orientechnologies.orient.core.command.*;
import com.orientechnologies.orient.core.db.document.ODatabaseDocument;
import com.orientechnologies.orient.core.db.record.OIdentifiable;
import com.orientechnologies.orient.core.exception.OCommandExecutionException;
import com.orientechnologies.orient.core.metadata.schema.OClass;
import com.orientechnologies.orient.core.metadata.schema.OSchema;
import com.orientechnologies.orient.core.metadata.security.ORole;
import com.orientechnologies.orient.core.metadata.security.ORule;
import com.orientechnologies.orient.core.record.ORecord;
import com.orientechnologies.orient.core.record.impl.ODocument;
import com.orientechnologies.orient.core.sql.OCommandSQLParsingException;
import com.orientechnologies.orient.core.sql.OIterableRecordSource;
import com.orientechnologies.orient.core.sql.filter.OSQLTarget;
import com.orientechnologies.orient.core.sql.query.OResultSet;
import com.orientechnologies.orient.core.sql.query.OSQLAsynchQuery;
import com.orientechnologies.orient.core.sql.query.OSQLSynchQuery;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.*;

public class OMatchStatement extends OStatement implements OCommandExecutor, OIterableRecordSource {

  String                             DEFAULT_ALIAS_PREFIX = "$ORIENT_DEFAULT_ALIAS_";

  private OSQLAsynchQuery<ODocument> request;

  long                               threshold            = 5;

  @Override
  public Iterator<OIdentifiable> iterator(Map<Object, Object> iArgs) {
    if (context == null) {
      context = new OBasicCommandContext();
    }
    Object result = execute(iArgs);
    return ((Iterable) result).iterator();
  }

  class MatchContext {
    String                     root;
    Map<String, Iterable>      candidates   = new HashMap<String, Iterable>();
    Map<String, OIdentifiable> matched      = new HashMap<String, OIdentifiable>();
    Map<PatternEdge, Boolean>  matchedEdges = new IdentityHashMap<PatternEdge, Boolean>();

    public MatchContext copy(String alias, OIdentifiable value) {
      MatchContext result = new MatchContext();
      result.root = alias;

      result.candidates.putAll(candidates);
      result.candidates.remove(alias);

      result.matched.putAll(matched);
      result.matched.put(alias, value);

      result.matchedEdges.putAll(matchedEdges);
      return result;
    }
  }

  class Pattern {
    Map<String, PatternNode> aliasToNode = new HashMap<String, PatternNode>();
    int                      numOfEdges  = 0;

    void addExpression(OMatchExpression expression) {
      PatternNode originNode = getOrCreateNode(expression.origin);

      for (OMatchPathItem item : expression.items) {
        String nextAlias = item.filter.getAlias();
        PatternNode nextNode = getOrCreateNode(item.filter);

        numOfEdges += originNode.addEdge(item, nextNode);
        originNode = nextNode;
      }
    }

    private PatternNode getOrCreateNode(OMatchFilter origin) {
      PatternNode originNode = get(origin.getAlias());
      if (originNode == null) {
        originNode = new PatternNode();
        originNode.alias = origin.getAlias();
        aliasToNode.put(originNode.alias, originNode);
      }
      return originNode;
    }

    PatternNode get(String alias) {
      return aliasToNode.get(alias);
    }

    int getNumOfEdges() {
      return numOfEdges;
    }
  }

  class PatternNode {
    String           alias;
    Set<PatternEdge> out        = new HashSet<PatternEdge>();
    Set<PatternEdge> in         = new HashSet<PatternEdge>();
    int              centrality = 0;

    int addEdge(OMatchPathItem item, PatternNode to) {
      PatternEdge edge = new PatternEdge();
      edge.item = item;
      edge.out = this;
      edge.in = to;
      this.out.add(edge);
      to.in.add(edge);
      return 1;
    }
  }

  class PatternEdge {
    PatternNode    in;
    PatternNode    out;
    OMatchPathItem item;
  }

  public static final String       KEYWORD_MATCH    = "MATCH";
  // parsed data
  protected List<OMatchExpression> matchExpressions = new ArrayList<OMatchExpression>();
  protected List<OIdentifier>      returnItems      = new ArrayList<OIdentifier>();

  protected Pattern                pattern;

  // execution data
  private OCommandContext          context;
  private OProgressListener        progressListener;

  public OMatchStatement() {
    super(-1);
  }

  public OMatchStatement(int id) {
    super(id);
  }

  public OMatchStatement(OrientSql p, int id) {
    super(p, id);
  }

  /**
   * Accept the visitor. *
   */
  public Object jjtAccept(OrientSqlVisitor visitor, Object data) {
    return visitor.visit(this, data);
  }

  @Override
  public <RET extends OCommandExecutor> RET parse(OCommandRequest iRequest) {
    final OCommandRequestText textRequest = (OCommandRequestText) iRequest;
    if (iRequest instanceof OSQLSynchQuery) {
      request = (OSQLSynchQuery<ODocument>) iRequest;
    } else if (iRequest instanceof OSQLAsynchQuery) {
      request = (OSQLAsynchQuery<ODocument>) iRequest;
    } else {
      // BUILD A QUERY OBJECT FROM THE COMMAND REQUEST
      request = new OSQLSynchQuery<ODocument>(textRequest.getText());
      if (textRequest.getResultListener() != null) {
        request.setResultListener(textRequest.getResultListener());
      }
    }
    String queryText = textRequest.getText();

    // please, do not look at this... refactor this ASAP with new executor structure
    final InputStream is = new ByteArrayInputStream(queryText.getBytes());
    final OrientSql osql = new OrientSql(is);
    try {
      OMatchStatement result = (OMatchStatement) osql.parse();
      this.matchExpressions = result.matchExpressions;
      this.returnItems = result.returnItems;
    } catch (ParseException e) {
      throw new OCommandSQLParsingException(e.getMessage(), e);
    }

    assignDefaultAliases(this.matchExpressions);
    pattern = new Pattern();
    for (OMatchExpression expr : this.matchExpressions) {
      pattern.addExpression(expr);
    }
    // TODO CHECK CORRECT RETURN STATEMENT!

    return (RET) this;
  }

  private void assignDefaultAliases(List<OMatchExpression> matchExpressions) {

    int counter = 0;
    for (OMatchExpression expression : matchExpressions) {
      if (expression.origin.getAlias() == null) {
        expression.origin.setAlias(DEFAULT_ALIAS_PREFIX + (counter++));
      }

      for (OMatchPathItem item : expression.items) {
        if (item.filter == null) {
          item.filter = new OMatchFilter(-1);
        }
        if (item.filter.getAlias() == null) {
          item.filter.setAlias(DEFAULT_ALIAS_PREFIX + (counter++));
        }
      }
    }
  }

  @Override
  public Object execute(Map<Object, Object> iArgs) {
    this.context.setInputParameters(iArgs);
    return execute(this.request, this.context);
  }

  public Object execute(OSQLAsynchQuery<ODocument> request, OCommandContext context) {
    Map<Object, Object> iArgs = context.getInputParameters();
    try {
      Map<String, OWhereClause> aliasFilters = new HashMap<String, OWhereClause>();
      Map<String, String> aliasClasses = new HashMap<String, String>();
      for (OMatchExpression expr : this.matchExpressions) {
        addAliases(expr, aliasFilters, aliasClasses);
      }

      Map<String, Long> estimatedRootEntries = estimateRootEntries(aliasClasses, aliasFilters);
      if (estimatedRootEntries.values().contains(0l)) {
        return new OResultSet();// some aliases do not match on any classes
      }

      calculateMatch(estimatedRootEntries, new MatchContext(), aliasClasses, aliasFilters, context, request);
      return getResult(request);
    } finally {

      if (request.getResultListener() != null) {
        request.getResultListener().end();
      }
    }

  }

  protected Object getResult(OSQLAsynchQuery<ODocument> request) {
    if (request instanceof OSQLSynchQuery)
      return ((OSQLSynchQuery<ODocument>) request).getResult();

    return null;
  }

  private boolean calculateMatch(Map<String, Long> estimatedRootEntries, MatchContext matchContext,
      Map<String, String> aliasClasses, Map<String, OWhereClause> aliasFilters, OCommandContext iCommandContext,
      OSQLAsynchQuery<ODocument> request) {
    return calculateMatch(pattern, estimatedRootEntries, matchContext, aliasClasses, aliasFilters, iCommandContext, request);

  }

  private boolean calculateMatch(Pattern pattern, Map<String, Long> estimatedRootEntries, MatchContext matchContext,
      Map<String, String> aliasClasses, Map<String, OWhereClause> aliasFilters, OCommandContext iCommandContext,
      OSQLAsynchQuery<ODocument> request) {

    List<MatchContext> activeContexts = new LinkedList<MatchContext>();

    MatchContext rootContext = new MatchContext();

    String smallestAlias = null;
    Long smallestAmount = Long.MAX_VALUE;
    boolean rootFound = false;
    // find starting nodes with few entries
    for (Map.Entry<String, Long> entryPoint : estimatedRootEntries.entrySet()) {
      if (entryPoint.getValue() < threshold) {
        String nextAlias = entryPoint.getKey();
        Iterable<OIdentifiable> matches = calculateMatches(nextAlias, aliasFilters, iCommandContext, aliasClasses);

        Set<OIdentifiable> ids = new HashSet<OIdentifiable>();
        if (!matches.iterator().hasNext()) {
          return true;
        }

        rootContext.candidates.put(nextAlias, matches);
        long thisAmount;
        if (matches instanceof Collection) {
          thisAmount = (long) ((Collection) matches).size();
        } else {
          thisAmount = estimatedRootEntries.get(nextAlias);
        }
        if (thisAmount <= smallestAmount) {
          smallestAlias = nextAlias;
          smallestAmount = thisAmount;
        }
        rootFound = true;
      }
    }
    // no nodes under threshold, guess the smallest one
    if (!rootFound) {
      String nextAlias = getNextAlias(estimatedRootEntries, matchContext);
      Iterable<OIdentifiable> matches = calculateMatches(nextAlias, aliasFilters, iCommandContext, aliasClasses);
      if (!matches.iterator().hasNext()) {
        return true;
      }
      smallestAlias = nextAlias;
      rootContext.candidates.put(nextAlias, matches);
    }

    Iterable<OIdentifiable> allCandidates = rootContext.candidates.get(smallestAlias);

    for (OIdentifiable id : allCandidates) {
      MatchContext childContext = rootContext.copy(smallestAlias, id);
      activeContexts.add(childContext);
    }

    while (!activeContexts.isEmpty()) {
      if (!processContext(pattern, estimatedRootEntries, activeContexts.remove(0), aliasClasses, aliasFilters, iCommandContext,
          request)) {
        return true;
      }
    }
    return true;
  }

  private Iterable<OIdentifiable> calculateMatches(String nextAlias, Map<String, OWhereClause> aliasFilters,
      OCommandContext iCommandContext, Map<String, String> aliasClasses) {
    Iterable<OIdentifiable> it = query(aliasClasses.get(nextAlias), aliasFilters.get(nextAlias), iCommandContext);
    Set<OIdentifiable> result = new HashSet<OIdentifiable>();
    // TODO dirty work around, review it. The iterable returned by the query just does not work.
    for (OIdentifiable id : it) {
      result.add(id.getIdentity());
    }

    return result;
  }

  private boolean processContext(Pattern pattern, Map<String, Long> estimatedRootEntries, MatchContext matchContext,
      Map<String, String> aliasClasses, Map<String, OWhereClause> aliasFilters, OCommandContext iCommandContext,
      OSQLAsynchQuery<ODocument> request) {

    if (pattern.getNumOfEdges() == matchContext.matchedEdges.size()) {
      addResult(matchContext, request);
      return true;
    }
    PatternNode rootNode = pattern.get(matchContext.root);
    Iterator<PatternEdge> edgeIterator = rootNode.out.iterator();
    while (edgeIterator.hasNext()) {
      PatternEdge outEdge = edgeIterator.next();

      if (!matchContext.matchedEdges.containsKey(outEdge)) {

        Object rightValues = executeTraversal(matchContext, iCommandContext, outEdge);
        if (!(rightValues instanceof Iterable)) {
          rightValues = Collections.singleton(rightValues);
        }
        for (OIdentifiable rightValue : (Iterable<OIdentifiable>) rightValues) {
          Iterable<OIdentifiable> prevMatchedRightValues = matchContext.candidates.get(outEdge.in.alias);

          if (prevMatchedRightValues != null && prevMatchedRightValues.iterator().hasNext()) {// just matching against known values
            for (OIdentifiable id : prevMatchedRightValues) {
              if (id.getIdentity().equals(rightValue.getIdentity())) {
                MatchContext childContext = matchContext.copy(outEdge.in.alias, id);
                if (edgeIterator.hasNext()) {
                  childContext.root = rootNode.alias;
                } else {
                  childContext.root = calculateNextRoot(pattern, childContext);
                }
                childContext.matchedEdges.put(outEdge, true);
                if (!processContext(pattern, estimatedRootEntries, childContext, aliasClasses, aliasFilters, iCommandContext,
                    request)) {
                  return false;
                }
              }
            }
          } else {// searching for neighbors
            OWhereClause where = aliasFilters.get(outEdge.in.alias);
            if (where == null || where.matchesFilters(rightValue, iCommandContext)) {
              MatchContext childContext = matchContext.copy(outEdge.in.alias, rightValue.getIdentity());
              if (edgeIterator.hasNext()) {
                childContext.root = rootNode.alias;
              } else {
                childContext.root = calculateNextRoot(pattern, childContext);
              }
              childContext.matchedEdges.put(outEdge, true);
              if (!processContext(pattern, estimatedRootEntries, childContext, aliasClasses, aliasFilters, iCommandContext, request)) {
                return false;
              }
            }
          }
        }
      }
    }
    edgeIterator = rootNode.in.iterator();
    while (edgeIterator.hasNext()) {
      PatternEdge inEdge = edgeIterator.next();
      if (!inEdge.item.isBidirectional()) {
        continue;
      }
      edgeIterator.remove();
      if (!matchContext.matchedEdges.containsKey(inEdge)) {
        Object leftValues = inEdge.item.method.executeReverse(matchContext.matched.get(matchContext.root), iCommandContext);
        if (!(leftValues instanceof Iterable)) {
          leftValues = Collections.singleton(leftValues);
        }
        for (OIdentifiable leftValue : (Iterable<OIdentifiable>) leftValues) {
          Iterable<OIdentifiable> prevMatchedRightValues = matchContext.candidates.get(inEdge.out.alias);

          if (prevMatchedRightValues.iterator().hasNext()) {// just matching against known values
            for (OIdentifiable id : prevMatchedRightValues) {
              if (id.getIdentity().equals(leftValue.getIdentity())) {
                MatchContext childContext = matchContext.copy(inEdge.out.alias, id);
                if (edgeIterator.hasNext()) {
                  childContext.root = rootNode.alias;
                } else {
                  childContext.root = calculateNextRoot(pattern, childContext);
                }
                childContext.matchedEdges.put(inEdge, true);

                if (!processContext(pattern, estimatedRootEntries, childContext, aliasClasses, aliasFilters, iCommandContext,
                    request)) {
                  return false;
                }
              }
            }
          } else {// searching for neighbors
            OWhereClause where = aliasFilters.get(inEdge.out.alias);
            if (where == null || where.matchesFilters(leftValue, iCommandContext)) {
              MatchContext childContext = matchContext.copy(inEdge.out.alias, leftValue.getIdentity());
              if (edgeIterator.hasNext()) {
                childContext.root = rootNode.alias;
              } else {
                childContext.root = calculateNextRoot(pattern, childContext);
              }
              childContext.matchedEdges.put(inEdge, true);
              if (!processContext(pattern, estimatedRootEntries, childContext, aliasClasses, aliasFilters, iCommandContext, request)) {
                return false;
              }
            }
          }
        }
      }
    }

    return true;
  }

  private String calculateNextRoot(Pattern pattern, MatchContext ctx) {
    return ctx.root;// TODO...?
  }

  private Object executeTraversal(MatchContext matchContext, OCommandContext iCommandContext, PatternEdge outEdge) {
    Iterable<OIdentifiable> queryResult = (Iterable) outEdge.item.method.execute(matchContext.matched.get(matchContext.root),
        iCommandContext);
    if (outEdge.item.filter == null || outEdge.item.filter.getFilter() == null) {
      return queryResult;
    }
    OWhereClause filter = outEdge.item.filter.getFilter();
    Set<OIdentifiable> result = new HashSet<OIdentifiable>();

    for (OIdentifiable origin : queryResult) {
      if (filter.matchesFilters(origin, iCommandContext)) {
        result.add(origin);
      }
    }
    return result;
  }

  private void addResult(MatchContext matchContext, OSQLAsynchQuery<ODocument> request) {
    if (returnsMatches()) {
      ODocument doc = getDatabase().newInstance();
      // TODO manage duplicates
      for (Map.Entry<String, OIdentifiable> entry : matchContext.matched.entrySet()) {
        if (isExplicitAlias(entry.getKey())) {
          doc.field(entry.getKey(), entry.getValue());
        }
      }
      Object result = getResult(request);

      if (request.getResultListener() != null) {
        request.getResultListener().result(doc);
      }
    } else if (returnsPaths()) {
      ODocument doc = getDatabase().newInstance();
      for (Map.Entry<String, OIdentifiable> entry : matchContext.matched.entrySet()) {
        doc.field(entry.getKey(), entry.getValue());
      }
      Object result = getResult(request);

      if (request.getResultListener() != null) {
        request.getResultListener().result(doc);
      }
    } else {
      ODocument doc = getDatabase().newInstance();
      for (OIdentifier alias : returnItems) {
        doc.field(alias.getValue(), matchContext.matched.get(alias.getValue()));
      }
      Object result = getResult(request);

      if (request.getResultListener() != null) {
        request.getResultListener().result(doc);
      }
    }
  }

  private boolean isExplicitAlias(String key) {
    if (key.startsWith(DEFAULT_ALIAS_PREFIX)) {
      return false;
    }
    return true;
  }

  private boolean returnsMatches() {
    for (OIdentifier item : returnItems) {
      if (item.getValue().equals("$matches")) {
        return true;
      }
    }
    return false;
  }

  private boolean returnsPaths() {
    for (OIdentifier item : returnItems) {
      if (item.getValue().equals("$paths")) {
        return true;
      }
    }
    return false;
  }

  private Iterable<OIdentifiable> query(String className, OWhereClause oWhereClause, OCommandContext ctx) {
    final ODatabaseDocument database = getDatabase();
    OClass schemaClass = database.getMetadata().getSchema().getClass(className);
    database.checkSecurity(ORule.ResourceGeneric.CLASS, ORole.PERMISSION_READ, schemaClass.getName().toLowerCase());

    Iterable<ORecord> baseIterable = fetchFromIndex(schemaClass, oWhereClause);
    // if (baseIterable == null) {
    // baseIterable = new ORecordIteratorClass<ORecord>((ODatabaseDocumentInternal) database, (ODatabaseDocumentInternal) database,
    // className, true, true);
    // }
    // Iterable<OIdentifiable> result = new FilteredIterator(baseIterable, oWhereClause);

    String text;

    if (oWhereClause == null) {
      text = "(select from " + className + ")";
    } else {
      text = "(select from " + className + " where " + oWhereClause.toString() + ")";
    }
    OSQLTarget target = new OSQLTarget(text, ctx, "where");

    return (Iterable) target.getTargetRecords();
  }

  private Iterable<ORecord> fetchFromIndex(OClass schemaClass, OWhereClause oWhereClause) {
    return null;// TODO
  }

  private String getNextAlias(Map<String, Long> estimatedRootEntries, MatchContext matchContext) {
    Map.Entry<String, Long> lowerValue = null;
    for (Map.Entry<String, Long> entry : estimatedRootEntries.entrySet()) {
      if (matchContext.matched.containsKey(entry.getKey())) {
        continue;
      }
      if (lowerValue == null) {
        lowerValue = entry;
      } else if (lowerValue.getValue() > entry.getValue()) {
        lowerValue = entry;
      }
    }

    return lowerValue.getKey();
  }

  private Map<String, Long> estimateRootEntries(Map<String, String> aliasClasses, Map<String, OWhereClause> aliasFilters) {
    Set<String> allAliases = new HashSet<String>();
    allAliases.addAll(aliasClasses.keySet());
    allAliases.addAll(aliasFilters.keySet());

    OSchema schema = getDatabase().getMetadata().getSchema();

    Map<String, Long> result = new HashMap<String, Long>();
    for (String alias : allAliases) {
      String className = aliasClasses.get(alias);
      if (className == null) {
        continue;
      }

      if (!schema.existsClass(className)) {
        throw new OCommandExecutionException("class not defined: " + className);
      }
      OClass oClass = schema.getClass(className);
      long upperBound;
      OWhereClause filter = aliasFilters.get(alias);
      if (filter != null) {
        upperBound = filter.estimate(oClass);
      } else {
        upperBound = oClass.count();
      }
      result.put(alias, upperBound);
    }
    return result;
  }

  private void addAliases(OMatchExpression expr, Map<String, OWhereClause> aliasFilters, Map<String, String> aliasClasses) {
    addAliases(expr.origin, aliasFilters, aliasClasses);
    for (OMatchPathItem item : expr.items) {
      if (item.filter != null) {
        addAliases(item.filter, aliasFilters, aliasClasses);
      }
    }
  }

  private void addAliases(OMatchFilter matchFilter, Map<String, OWhereClause> aliasFilters, Map<String, String> aliasClasses) {
    String alias = matchFilter.getAlias();
    OWhereClause filter = matchFilter.getFilter();
    if (alias != null) {
      if (filter != null && filter.baseExpression != null) {
        OWhereClause previousFilter = aliasFilters.get(alias);
        if (previousFilter == null) {
          previousFilter = new OWhereClause(-1);
          previousFilter.baseExpression = new OAndBlock(-1);
          aliasFilters.put(alias, previousFilter);
        }
        OAndBlock filterBlock = (OAndBlock) previousFilter.baseExpression;
        if (filter != null && filter.baseExpression != null) {
          filterBlock.subBlocks.add(filter.baseExpression);
        }
      }

      String clazz = matchFilter.getClassName();
      if (clazz != null) {
        String previousClass = aliasClasses.get(alias);
        if (previousClass == null) {
          aliasClasses.put(alias, clazz);
        } else {
          String lower = getLowerSubclass(clazz, previousClass);
          if (lower == null) {
            throw new OCommandExecutionException("classes defined for alias " + alias + " (" + clazz + ", " + previousClass
                + ") are not in the same hierarchy");
          }
          aliasClasses.put(alias, lower);
        }
      }
    }
  }

  private String getLowerSubclass(String className1, String className2) {
    OSchema schema = getDatabase().getMetadata().getSchema();
    OClass class1 = schema.getClass(className1);
    OClass class2 = schema.getClass(className2);
    if (class1.isSubClassOf(class2)) {
      return class1.getName();
    }
    if (class2.isSubClassOf(class1)) {
      return class2.getName();
    }
    return null;
  }

  @Override
  public <RET extends OCommandExecutor> RET setProgressListener(OProgressListener progressListener) {

    this.progressListener = progressListener;
    return (RET) this;
  }

  @Override
  public <RET extends OCommandExecutor> RET setLimit(int iLimit) {
    // TODO
    return (RET) this;
    // throw new UnsupportedOperationException();
  }

  @Override
  public String getFetchPlan() {
    return null;
  }

  @Override
  public Map<Object, Object> getParameters() {
    return null;
  }

  @Override
  public OCommandContext getContext() {
    return context;
  }

  @Override
  public void setContext(OCommandContext context) {
    this.context = context;
  }

  @Override
  public boolean isIdempotent() {
    return true;
  }

  @Override
  public Set<String> getInvolvedClusters() {
    return Collections.EMPTY_SET;
  }

  @Override
  public int getSecurityOperationType() {
    return ORole.PERMISSION_READ;
  }

  @Override
  public boolean involveSchema() {
    return false;
  }

  @Override
  public long getTimeout() {
    return -1;
  }

  @Override
  public String getSyntax() {
    return "MATCH <match-statement> [, <match-statement] RETURN <alias>[, <alias>]";
  }

  @Override
  public boolean isLocalExecution() {
    return false;
  }

  @Override
  public String toString() {
    StringBuilder result = new StringBuilder();
    result.append(KEYWORD_MATCH);
    result.append(" ");
    boolean first = true;
    for (OMatchExpression expr : this.matchExpressions) {
      if (!first) {
        result.append(", ");
      }
      result.append(expr.toString());
      first = false;
    }
    result.append(" RETURN ");
    first = true;
    for (OIdentifier expr : this.returnItems) {
      if (!first) {
        result.append(", ");
      }
      result.append(expr.toString());
      first = false;
    }
    return result.toString();
  }
}
/* JavaCC - OriginalChecksum=6ff0afbe9d31f08b72159fcf24070c9f (do not edit this line) */
