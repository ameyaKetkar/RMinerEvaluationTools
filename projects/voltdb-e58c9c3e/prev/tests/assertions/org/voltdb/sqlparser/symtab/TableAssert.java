package org.voltdb.sqlparser.symtab;

import org.assertj.core.api.AbstractAssert;
import org.assertj.core.api.Condition;
import org.assertj.core.api.Fail;
import org.voltdb.sqlparser.semantics.symtab.Column;
import org.voltdb.sqlparser.semantics.symtab.Table;

/**
 * {@link Table} specific assertions - Generated by CustomAssertionGenerator.
 */
public class TableAssert extends AbstractAssert<TableAssert, Table> {

    /**
     * Creates a new </code>{@link TableAssert}</code> to make assertions on actual Table.
     * @param actual the Table we want to make assertions on.
     */
    public TableAssert(Table actual) {
        super(actual, TableAssert.class);
    }

    /**
     * An entry point for TableAssert to follow AssertJ standard <code>assertThat()</code> statements.<br>
     * With a static import, one's can write directly : <code>assertThat(myTable)</code> and get specific assertion with code completion.
     * @param actual the Table we want to make assertions on.
     * @return a new </code>{@link TableAssert}</code>
     */
    public static TableAssert assertThat(Table actual) {
        return new TableAssert(actual);
    }

    public static Condition<Table> withColumnNamed(final String aColumnName,
                                                    final Condition<Column> ...conditions) {
        return new Condition<Table>() {
            @Override
            public boolean matches(Table aValue) {
                Column col = aValue.getColumnByName(aColumnName);
                if (col == null) {
                    Fail.fail(String.format("Expected column named <%s>", aColumnName));
                }
                for (Condition<Column> cond : conditions) {
                    org.voltdb.sqlparser.symtab.ColumnAssert.assertThat(col).has(cond);
                }
                return true;
            }
        };
    }
}
