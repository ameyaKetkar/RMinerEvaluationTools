package jetbrains.mps.migration.component.util;

/*Generated by MPS */

import com.intellij.openapi.components.AbstractProjectComponent;
import jetbrains.mps.ide.migration.MigrationManager;
import jetbrains.mps.lang.migration.runtime.base.DataCollector;

import java.util.Map;

import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.lang.migration.runtime.base.MigrationDescriptor;
import jetbrains.mps.internal.collections.runtime.MapSequence;

import java.util.HashMap;

import jetbrains.mps.project.Project;
import jetbrains.mps.smodel.tempmodel.TempModuleOptions;
import jetbrains.mps.migration.global.ProjectMigration;

import javax.swing.SwingUtilities;

import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.apache.log4j.Level;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.migration.runtime.base.MigrationScript;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.ide.migration.ScriptApplied;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.migration.runtime.util.MigrationsUtil;
import jetbrains.mps.project.AbstractModule;

import java.util.List;

import jetbrains.mps.migration.global.ProjectMigrationsRegistry;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;

import java.util.ArrayList;

import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.migration.global.CleanupProjectMigration;
import jetbrains.mps.migration.global.ProjectMigrationWithOptions;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.SLanguageHierarchy;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;

import java.util.Collection;

import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class MigrationComponent extends AbstractProjectComponent implements MigrationManager, DataCollector {
  private Map<SModule, MigrationDescriptor> loadedDescriptors = MapSequence.fromMap(new HashMap<SModule, MigrationDescriptor>());
  private Project mpsProject;
  private SModule dataModule;
  private TempModuleOptions dataModuleOptions;
  private ProjectMigration lastProjectMigration;

  public MigrationComponent(com.intellij.openapi.project.Project project, Project mpsProject) {
    super(project);
    this.mpsProject = mpsProject;
    lastProjectMigration = null;
  }

  @Override
  public void initComponent() {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        dataModuleOptions = TempModuleOptions.forDefaultModule();
        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            dataModule = dataModuleOptions.createModule();
          }
        });
      }
    });
  }

  @Override
  public void disposeComponent() {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
          public void run() {
            dataModuleOptions.disposeModule();
          }
        });
      }
    });
  }

  public MigrationDescriptor loadMigrationDescriptor(final Language module) {
    final Wrappers._T<String> name = new Wrappers._T<String>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        name.value = getDescriptorFQName(module);
      }
    });
    try {
      Class descriptorClass = module.getClass(name.value);
      return (MigrationDescriptor) descriptorClass.newInstance();
    } catch (ClassNotFoundException e) {
      return null;
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Exception on migration descriptor instantiation", e);
      }
      return null;
    }
  }

  public String getDescriptorFQName(SModule module) {
    return module.getModuleName() + "." + LanguageAspect.MIGRATION.getName() + "." + BehaviorReflection.invokeNonVirtualStatic(String.class,
        SNodeOperations.asSConcept(MetaAdapterFactory.getConcept(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x73e8a2c68b62c6a3L,
            "jetbrains.mps.lang.migration.structure.MigrationScript").getDeclarationNode()), "call_getGeneratedClassName_8648538385393994830", new Object[]{});
  }

  public MigrationDescriptor getMigrationDescriptor(Language module) {
    if (MapSequence.fromMap(loadedDescriptors).get(module) == null) {
      MapSequence.fromMap(loadedDescriptors).put(module, loadMigrationDescriptor(module));
    }
    return MapSequence.fromMap(loadedDescriptors).get(module);
  }

  public void clearCache() {
    MapSequence.fromMap(loadedDescriptors).clear();
  }

  public MigrationScript fetchScript(MigrationScriptReference scriptReference) {
    SLanguage depLanguage = scriptReference.getLanguage();
    int current = scriptReference.getFromVersion();
    MigrationDescriptor md = getMigrationDescriptor((Language) depLanguage.getSourceModule());
    if (md == null) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load migration descriptor for language " + depLanguage + ".");
      }
    }
    MigrationScript script = check_gd1mrb_a0e0u(md, current);
    if (script == null) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Could not load migration script for language " + depLanguage + ", version " + current + ".");
      }
      return null;
    }
    return script;
  }

  public static boolean areDepsSatisfied(final ScriptApplied p) {
    Iterable<MigrationScriptReference> requiresData = p.getScript().requiresData();
    boolean dataDeps = Sequence.fromIterable(requiresData).all(new IWhereFilter<MigrationScriptReference>() {
      public boolean accept(MigrationScriptReference it) {
        return MigrationsUtil.isAppliedForAllMyDeps(it, p.getModule());
      }
    });
    Iterable<MigrationScriptReference> executeAfter = p.getScript().executeAfter();
    boolean orderDeps = Sequence.fromIterable(executeAfter).all(new IWhereFilter<MigrationScriptReference>() {
      public boolean accept(MigrationScriptReference it) {
        return MigrationsUtil.isApplied(it, (AbstractModule) p.getModule());
      }
    });
    if (dataDeps && orderDeps) {
      return true;
    }
    return false;
  }

  public boolean isMigrationRequired() {
    final Wrappers._boolean result = new Wrappers._boolean(false);
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(mpsProject);
        result.value = isMigrationRequired(mpsProject, modules);
      }
    });
    return result.value;
  }

  public static boolean isMigrationRequired(final Project p, Iterable<SModule> modules) {
    List<ProjectMigration> pMig = ProjectMigrationsRegistry.getInstance().getMigrations();
    boolean projectMig = ListSequence.fromList(pMig).any(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        return it.shouldBeExecuted(p);
      }
    });
    boolean languageMig = isLanguageMigrationRequired(modules);
    return projectMig || languageMig;
  }

  public List<Tuples._3<SModule, SLanguage, Integer>> getMissingMigrations() {
    final List<Tuples._3<SModule, SLanguage, Integer>> result = ListSequence.fromList(new ArrayList<Tuples._3<SModule, SLanguage, Integer>>());
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(ProjectHelper.toMPSProject(myProject));
        for (SModule module : Sequence.fromIterable(modules)) {
          for (SLanguage lang : SetSequence.fromSet(((AbstractModule) module).getAllUsedLanguages())) {
            int currentLangVersion = lang.getLanguageVersion();
            int ver = ((AbstractModule) module).getUsedLanguageVersion(lang);

            ver = Math.max(ver, 0);
            currentLangVersion = Math.max(currentLangVersion, 0);

            if (ver >= currentLangVersion) {
              continue;
            }
            for (int v = ver; v < currentLangVersion; v++) {
              if (fetchScript(new MigrationScriptReference(lang, v)) == null) {
                ListSequence.fromList(result).addElement(MultiTuple.<SModule, SLanguage, Integer>from(module, lang, v));
                // next used language, please 
                break;
              }
            }
          }
        }
      }
    });
    return result;
  }

  public static boolean isLanguageMigrationRequired(Iterable<SModule> modules) {
    return Sequence.fromIterable(modules).ofType(AbstractModule.class).any(new IWhereFilter<AbstractModule>() {
      public boolean accept(final AbstractModule module) {
        return Sequence.fromIterable(MigrationsUtil.getNextStepScripts(module)).any(new IWhereFilter<MigrationScriptReference>() {
          public boolean accept(MigrationScriptReference item) {
            return MigrationsUtil.isMigrationNeeded(item.getLanguage(), item.getFromVersion(), module);
          }
        });
      }
    });
  }

  public boolean executeScript(ScriptApplied sa) {
    MigrationScript script = sa.getScript();
    AbstractModule module = ((AbstractModule) sa.getModule());
    SLanguage fromLanguage = script.getDescriptor().getLanguage();
    Integer usedVersion = module.getModuleDescriptor().getLanguageVersions().get(fromLanguage);
    usedVersion = Math.max(usedVersion, 0);
    assert usedVersion == script.getDescriptor().getFromVersion();
    try {
      SNode data = script.execute(module, this);
      if (data != null) {
        MigrationDataUtil.addData(module, dataModule, script.getDescriptor(), data);
      }
    } catch (Throwable e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error("Could not execute script", e);
      }
      return false;
    }

    int toVersion = script.getDescriptor().getFromVersion() + 1;
    module.getModuleDescriptor().getLanguageVersions().put(fromLanguage, toVersion);
    module.setChanged();

    for (SModel model : ListSequence.fromList(module.getModels())) {
      if (model.isReadOnly()) {
        continue;
      }
      if (!((model instanceof SModelInternal))) {
        continue;
      }
      if (!(((SModelInternal) model).importedLanguageIds().contains(fromLanguage))) {
        continue;
      }

      ((SModelInternal) model).deleteLanguageId(fromLanguage);
      ((SModelInternal) model).addLanguage(fromLanguage, toVersion);
    }

    return true;
  }

  public int projectStepsCount(boolean isCleanup) {
    List<ProjectMigration> migrations = ProjectMigrationsRegistry.getInstance().getMigrations();
    int cleanupSize = ListSequence.fromList(migrations).ofType(CleanupProjectMigration.class).count();
    return (isCleanup ? cleanupSize : ListSequence.fromList(migrations).count() - cleanupSize);
  }

  public MigrationManager.MigrationStep nextProjectStep(Map<String, Object> options, boolean cleanup) {
    ProjectMigration current = next(lastProjectMigration, cleanup);

    while (current != null && !(current.shouldBeExecuted(mpsProject))) {
      current = next(current, cleanup);
    }

    if (current == null) {
      return null;
    }

    lastProjectMigration = current;
    if (current instanceof ProjectMigrationWithOptions) {
      ((ProjectMigrationWithOptions) current).setOptionValues(options);
    }

    final ProjectMigration cc = current;
    return new MigrationManager.MigrationStep() {
      public String getDescription() {
        return cc.getDescription();
      }

      public boolean execute() {
        try {
          ModelAccess.instance().runWriteActionInCommand(new Runnable() {
            public void run() {
              cc.execute(mpsProject);
            }
          });
        } catch (Throwable e) {
          if (LOG.isEnabledFor(Level.ERROR)) {
            LOG.error("Could not execute script", e);
          }
          return false;
        }
        return true;
      }

      public void forceExecutionNextTime() {
        if (!((cc instanceof CleanupProjectMigration))) {
          throw new UnsupportedOperationException("only supported for cleanup project migrations");
        }
        ((CleanupProjectMigration) cc).forceExecutionNextTime(mpsProject);
      }
    };
  }

  private ProjectMigration next(ProjectMigration current, final boolean cleanup) {
    List<ProjectMigration> mig = ProjectMigrationsRegistry.getInstance().getMigrations();

    mig = ListSequence.fromList(mig).where(new IWhereFilter<ProjectMigration>() {
      public boolean accept(ProjectMigration it) {
        boolean isCleanup = it instanceof CleanupProjectMigration;
        // this is xor, which is absent in bl 
        return (cleanup ? isCleanup : !(isCleanup));
      }
    }).toListSequence();

    if (ListSequence.fromList(mig).isEmpty()) {
      return null;
    }

    if (ListSequence.fromList(mig).indexOf(current) < 0) {
      // was: cleanup, now: not cleanup 
      current = null;
    }
    if (current == null) {
      return ListSequence.fromList(mig).getElement(0);
    }

    int index = ListSequence.fromList(mig).indexOf(current);
    if (index == ListSequence.fromList(mig).count() - 1) {
      return null;
    }
    return ListSequence.fromList(mig).getElement(index + 1);
  }

  public int languageStepsCount() {
    final Wrappers._int result = new Wrappers._int();
    ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Integer>() {
      public Integer invoke() {
        Iterable<Integer> scriptsByModule =
            Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(mpsProject)).ofType(AbstractModule.class).select(
                new ISelector<AbstractModule, Integer>() {
                  public Integer select(AbstractModule module) {
                    int scripts = 0;
                    for (SLanguage lang : SetSequence.fromSet(new SLanguageHierarchy(module.getUsedLanguages()).getExtended())) {
                      int currentLangVersion = lang.getLanguageVersion();
                      int ver = module.getUsedLanguageVersion(lang);

                      ver = Math.max(ver, 0);
                      currentLangVersion = Math.max(currentLangVersion, 0);

                      if (ver < currentLangVersion) {
                        scripts += currentLangVersion - ver;
                      }
                    }
                    return scripts;
                  }
                });
        return result.value = Sequence.fromIterable(scriptsByModule).foldLeft(0, new ILeftCombinator<Integer, Integer>() {
          public Integer combine(Integer s, Integer it) {
            return s + it;
          }
        });
      }
    }));
    return result.value;
  }

  public MigrationManager.MigrationStep nextLanguageStep() {
    final Wrappers._T<MigrationManager.MigrationStep> result = new Wrappers._T<MigrationManager.MigrationStep>(null);

    ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Boolean>() {
      public Boolean invoke() {
        Collection<ScriptApplied> scripts = CollectionSequence.fromCollection(new ArrayList<ScriptApplied>());

        return Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(ProjectHelper.toMPSProject(myProject))).ofType(AbstractModule.class).any(
            new IWhereFilter<AbstractModule>() {
              public boolean accept(final AbstractModule module) {
                return Sequence.fromIterable(MigrationsUtil.getNextStepScripts(module)).any(new IWhereFilter<MigrationScriptReference>() {
                  public boolean accept(MigrationScriptReference it) {
                    if (!(MigrationsUtil.isMigrationNeeded(it.getLanguage(), it.getFromVersion(), module))) {
                      return false;
                    }
                    MigrationScript loaded = fetchScript(it);
                    if (loaded == null) {
                      return false;
                    }
                    final ScriptApplied applied = new ScriptApplied(loaded, module);
                    if (!(areDepsSatisfied(applied))) {
                      return false;
                    }
                    result.value = new MigrationManager.MigrationStep() {
                      public String getDescription() {
                        return applied.toString();
                      }

                      public boolean execute() {
                        final Wrappers._boolean res = new Wrappers._boolean();
                        ModelAccess.instance().runWriteActionInCommand(new Runnable() {
                          public void run() {
                            res.value = executeScript(applied);
                          }
                        });
                        return res.value;
                      }

                      public void forceExecutionNextTime() {
                        throw new UnsupportedOperationException("not supported for language migrations");
                      }
                    };
                    return true;
                  }
                });
              }
            });
      }
    }));

    return result.value;
  }

  public Map<SModule, SNode> collectData(SModule myModule, final MigrationScriptReference scriptReference) {
    final Map<SModule, SNode> requiredData = MapSequence.fromMap(new HashMap<SModule, SNode>());
    SetSequence.fromSet(MigrationsUtil.getModuleDependencies(myModule)).visitAll(new IVisitor<SModule>() {
      public void visit(SModule it) {
        SNode dataString = MigrationDataUtil.readData(it, scriptReference);
        if (dataString != null) {
          MapSequence.fromMap(requiredData).put(it, dataString);
        }
      }
    });
    return requiredData;
  }

  protected static Logger LOG = LogManager.getLogger(MigrationComponent.class);

  private static MigrationScript check_gd1mrb_a0e0u(MigrationDescriptor checkedDotOperand, int current) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getScript(current);
    }
    return null;
  }
}
